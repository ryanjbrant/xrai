#!/usr/bin/env node

/**
 * KB-CLI Documentation Updater
 * 
 * This script ensures all documentation is kept in sync with the codebase.
 * It should be run as part of the pre-commit hook and CI/CD pipeline.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Configuration
const CONFIG = {
  ROOT_DIR: path.resolve(__dirname, '..'),
  DOCS_DIR: path.resolve(__dirname, '../docs'),
  EXTENSION_DIR: path.resolve(__dirname, '../chrome-extension'),
  IGNORE_PATTERNS: ['node_modules', '.git', 'dist', 'build'],
  FILE_HEADER: `<!-- 
  AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
  Last updated: ${new Date().toISOString()}
  Generated by: ${path.basename(__filename)}
-->
`
};

/**
 * Update API documentation
 */
async function updateApiDocs() {
  console.log('Updating API documentation...');
  
  // Generate TypeScript type documentation
  try {
    execSync('npx typedoc --options typedoc.json', { stdio: 'inherit' });
    console.log('Type documentation generated successfully');
  } catch (error) {
    console.error('Failed to generate type documentation:', error);
    process.exit(1);
  }
  
  // Update API reference
  const apiReferencePath = path.join(CONFIG.DOCS_DIR, 'api-reference.md');
  let apiContent = `${CONFIG.FILE_HEADER}
# API Reference\n\n`;
  
  // Add auto-generated content
  apiContent += '## KnowledgeBaseIntegrator\n\n';
  apiContent += 'Manages integration between browser history and knowledge base.\n\n';
  apiContent += '### Methods\n\n';
  apiContent += '- `processInsights(analysis)`: Processes browser history analysis into knowledge items\n';
  apiContent += '- `mergeWithExistingKnowledge(existing, newItems)`: Merges new insights with existing knowledge\n\n';
  
  fs.writeFileSync(apiReferencePath, apiContent);
  console.log('API reference updated');
}

/**
 * Update feature documentation
 */
async function updateFeatureDocs() {
  console.log('Updating feature documentation...');
  const featuresPath = path.join(CONFIG.DOCS_DIR, 'features.md');
  
  let featuresContent = `${CONFIG.FILE_HEADER}
# Feature Documentation\n\n`;
  
  // Add browser history analysis section
  featuresContent += '## Browser History Analysis\n\n';
  featuresContent += 'The extension analyzes your browsing history to identify patterns and interests.\n\n';
  featuresContent += '### How It Works\n\n';
  featuresContent += '1. **Collection**: Browser history is processed locally\n';
  featuresContent += '2. **Analysis**: Domains are categorized and keywords extracted\n';
  featuresContent += '3. **Storage**: Insights are stored in your knowledge base\n\n';
  
  // Add knowledge integration section
  featuresContent += '## Knowledge Integration\n\n';
  featuresContent += 'Seamlessly integrates with your KB-CLI instance.\n\n';
  
  fs.writeFileSync(featuresPath, featuresContent);
  console.log('Feature documentation updated');
}

/**
 * Update CHANGELOG.md with recent changes
 */
async function updateChangelog() {
  console.log('Updating CHANGELOG.md...');
  
  // Get recent git commits for the changelog
  let changes;
  try {
    changes = execSync('git log --pretty=format:"- %s (%h)" --since="1 week ago"')
      .toString()
      .trim();
  } catch (error) {
    console.warn('Could not get git history:', error.message);
    changes = '- Minor updates and bug fixes';
  }
  
  const changelogPath = path.join(CONFIG.ROOT_DIR, 'CHANGELOG.md');
  let currentContent = '';
  
  if (fs.existsSync(changelogPath)) {
    currentContent = fs.readFileSync(changelogPath, 'utf8');
  }
  
  const newEntry = `## [${new Date().toISOString().split('T')[0]}] - Update\n\n${changes}\n\n`;
  
  fs.writeFileSync(changelogPath, newEntry + currentContent);
  console.log('CHANGELOG.md updated');
}

/**
 * Update TODO.md with current tasks
 */
async function updateTodoList() {
  console.log('Updating TODO.md...');
  
  // Find all TODO comments in the codebase
  let todos = [];
  
  function scanDirectory(dir) {
    const files = fs.readdirSync(dir);
    
    files.forEach(file => {
      const fullPath = path.join(dir, file);
      const stat = fs.statSync(fullPath);
      
      if (CONFIG.IGNORE_PATTERNS.some(pattern => fullPath.includes(pattern))) {
        return;
      }
      
      if (stat.isDirectory()) {
        scanDirectory(fullPath);
      } else if (stat.isFile() && ['.js', '.ts', '.jsx', '.tsx', '.md'].includes(path.extname(file))) {
        const content = fs.readFileSync(fullPath, 'utf8');
        const todoMatches = content.matchAll(/\/\/\s*TODO:?(.*?)(?:\n|$)/g);
        
        for (const match of todoMatches) {
          const relativePath = path.relative(CONFIG.ROOT_DIR, fullPath);
          todos.push({
            file: relativePath,
            text: match[1].trim(),
            line: content.substring(0, match.index).split('\n').length
          });
        }
      }
    });
  }
  
  scanDirectory(CONFIG.ROOT_DIR);
  
  // Generate TODO.md content
  let todoContent = `${CONFIG.FILE_HEADER}
# TODO List\n\n`;
  
  if (todos.length === 0) {
    todoContent += 'No pending TODOs found. Great job! üéâ\n';
  } else {
    // Group by file
    const todosByFile = {};
    todos.forEach(todo => {
      if (!todosByFile[todo.file]) {
        todosByFile[todo.file] = [];
      }
      todosByFile[todo.file].push(todo);
    });
    
    // Generate sections for each file
    for (const [file, fileTodos] of Object.entries(todosByFile)) {
      todoContent += `## ${file}\n\n`;
      
      fileTodos.forEach(todo => {
        todoContent += `- [ ] **Line ${todo.line}**: ${todo.text}\n`;
      });
      
      todoContent += '\n';
    }
  }
  
  fs.writeFileSync(path.join(CONFIG.ROOT_DIR, 'TODO.md'), todoContent);
  console.log(`Found ${todos.length} TODOs`);
}

/**
 * Main function
 */
async function main() {
  console.log('Starting documentation update...');
  
  try {
    await updateApiDocs();
    await updateFeatureDocs();
    await updateChangelog();
    await updateTodoList();
    
    console.log('\n‚úÖ Documentation update complete!');
  } catch (error) {
    console.error('‚ùå Error updating documentation:', error);
    process.exit(1);
  }
}

// Run the script
if (require.main === module) {
  main();
}

module.exports = {
  updateApiDocs,
  updateFeatureDocs,
  updateChangelog,
  updateTodoList
};
